                                                                                                                              一、java
1.java的初识	
   机器语言--》汇编语言--》高级语言--》（面向过程）{C、pascal、cobol、fortran、Ada、}（面向对象）{C++、Python、java、c#}
    一代语言   ||   二代语言  ||     三代语言

2.


                                                                                                                           二、java的历史

1.sun公司

2.java为什么被发明：要求语言中立、也就是跨平台



3.发明人：James Gosling



4.经历阶段：






							          三、java的结构体系（所包含的类不同）

1.javaSE(java Standard Edition):标准版，定位在个人计算机上的应用





2.javaEE(java Enterprise Edition):企业版 ，定位于在服务器的应用、网站






3.javaME(java Micro Edition):微机版，定位于在消费行电子产品的应用上


							        四、Java的特性和优势




1.跨平台、可移植性


2.安全性


3.面向对象



4.简单性



5.高性能



6.分布式



7.多线程



8.健壮性





						                      五、  java垃圾收集机制

垃圾收集的目的在除不再使用的对象，当对象建立的时候垃圾收集期，就开始监控对象的动态情况，垃圾收集主要是对内存的释放。创建对象的时候申请一个空间。

1.不再使用内存空间应回收--》垃圾收集；

2.java消除了程序员回收无用内存空间的职责；提供一种系统及线程跟踪存储空间的分配情况。再jvm的空闲时，检查并释放可释放的存储空间；相比c++吗，开发人员无法负责自己收回无用内存。

3.垃圾收集在java程序运行过程自动进行，程序员无法精确控制和干预；

4.GC的自动回收，提高了内存空间的利用效率，也提高编程人员的效率。很大程度上减少因为没有释放空间而导致的内存泄露。



后续：
更高级：
1.垃圾收集器有几种
2.垃圾收集器底层原理剖析
3.垃圾收集器算法、优化。



							       六、java跨平台原理

1.
.java：为源文件


HelloWorld.java--->(编译) java.exe---> HelloWorld.class ---》(执行/翻译) java.exe -->  windows(虚拟机 (JVM))//相当于翻译官
       源文件         ||                   字节码文件



2.
HelloWorld.java--->()





							  七、
1.c语言的跨平台原理

HelloWorld.c  ---》  windows编译器  ---》编译后产生的可执行文件可以在对应平台上运行 ---》 windows
   源文件              ||    
 
HelloWorld.c  ---》  linux编译器  ---》编译后产生的可执行文件可以在对应平台上运行 ---》 linux    

C跨平台和Java跨平台区别
（1）java的字节码文件是跟平台无关的，拿着这个字节码文件到不同的平台上运行

  (2) C语言不同的平台有不同的编译器，编译器与平台相关的，编译后的可执行文件也跟平台相关
c语言到底是不是跨平台的？
实际上我们所说跨平台指的是：编译后的文件是否跨平台---》从这个角度来看，c语言不是跨平台的，
而网上很多人说C语言的是跨平台，因为不同有不同的解释器，它指的是源文件跨平台。

C语言的效率高还是java语言的效率高？C语言的效率高，因为它产生的可执行文件可以直接在平台上运行





							     八、常用的dos命令

1.dos命令 ：win+r  输入 ：cmd
2.具体的dos命令
    	1）切换盘符  ：c:    d:     e:   （不区分大小写）
	2）显示详细信息： dir 
	3）改变当前目录：cd
	4)  .代表当前目录      ..代表上层目录
	5）清屏:cls 
	6) 切换历史命令 ：上下键
	7）补全命令 ：Tab键
	8）创建目录：md
	9)  删除目录：rd
              10)  复制文件：copy   xxx.txt      a\  xxx.txt  
              11)  删除文件：del     //del后面如果接的是文件夹/目录：那么删除的就是这个文件夹下的文件，而不是文件夹
              12）



							  九、常见的错误

1.最低级的错误：单词拼写错误
2.要求源文件名字和类名必须一样
3.所有的标点必须是英文状态下的
4.成对的编程符号
5.注意缩进 tab    向前缩进 shift+tab
6.编译：javac Helloworld.java
7.执行：java Helloworld 
8.java 中的大小写敏感   
9.我们要写代码：就当一个框子
10.一个源文件中可以有多类，只能有一个类被public修饰，源文件的名字必须跟public修饰的那个类名必须保持一致。
11.多个类会产生独立的字节码文件：


							 十、编译方式

1.








							十一、环境变量

1.classpath:    
	.\
	系统有一个环境变量叫：classpath,现在我们将classpath环境变量显示出来：
classpath作用：只要你配置到claaspath中的路径，在执行java的字节码的时候，就会去配置的路径下找，对应的字节码文件。

2.classpath:
	E:\train_code
	自从我配置了这个文件变量以后，可以在任意的路径下去执行字节码文件：		
				
3.home:    （后续我们会用到一个软件:tomecat,在执行startup.bat的时候回出现闪退的问题）
	解决：配置java-home的环境变量
我再次启动，会成功 





							十二、注释
1.单行注释：//
2.多行注释：/*   */
3.文档注释：
/*
@xxxx
@xxxx
xxxxxxxxxxxx
*/





						                        第二章
							      一、数据类型
1.标识符（biaozhifu）
1)什么是标识符：
	        包、类、变量、方法........，只要起名字的地方，那个名字就是标识符
2)标识符的定义规则：
	     ①四个可以（组成部分）：数字、字母、下划线、美元符号$   注意：字母概念比较宽泛，指的是英文字母，汉字，日语，俄语.......
	     ②两个不可以：不可以以数字开头，不可以使用java的关键字
	     ③见名知意：增强可读性
	     ④大小写敏感
	     ⑤遵照驼峰命名：
			类名：首字母大写  ，其余遵守驼峰命名 
			方法名,变量名：首字母小写，其余遵守驼峰命名
			包名：全部小写，不遵守驼峰命名。

	     ⑥长度无限制，但是不建议太长


2.关键字

(1)用于数据类型。
　　用于数据类型的关键字有 boolean、byte、char、 double、 false、float、int、long、new、short、true、void、instanceof。
(2)用于语句。
　　用于语句的关键字有break、case、 catch、 continue、 default 、do、 else、 for、 if、return、switch、try、 while、 finally、 throw、this、 super。
(3)用于修饰
　　用于修饰的关键字有 abstract、final、native、private、 protected、public、static、synchronized、
　　transient、 volatile。
(4)用于方法、类、接口、包和异常。
　　用于方法、类、接口、包和异常的关键字有 class、 extends、 implements、interface、 package、import、throws。
　　还有些关键字,如cat、 future、 generic、innerr、 operator、 outer、rest、var等都是Java保留的没有意义的关键字。
　　另外，Java还有3个保留字:true、false、null。它们不是关键字，而是文字。包含Java定义的值。和关键字一样,它们也不可以作为标识符使用。










							   二、常量和变量



1.常量:
常量分为两种：
          	     常量通常指的是一个固定的值，例如：1，2，3，4，5, ' a', 'b',  ture, false, "helloworld" 等。
在java语言中，主要是利用关键字final来定义一个常量。常量一旦被初始化后不能再使更改其值。
为了更好的区分和表述，一般将 1,2,3, 'a', 'b',  ture, false、"helloworld" 等称为字面常量；而使用final修饰的PI等称为符号常量。（字符常量）
	
字面常量的类型：
整型常量 123 23
实型常量 3.1415926
字符常量 ‘a’
逻辑常量  true false
字符常量  "helloworld"







2.变量:
          变量本质就是代表一个”可操作的存储空间“，空间位置确定的，但是里面放置什么值不确定。我们可通过变量名来访问”对应的存储空间“，
从操作这个”存储空间“存储的值。java是一种强类型语言，每个变量都必须声明其数据类型。变量的数据类型决定了变量占存储空间的大小。
比如，int a=3;表示a变量的空间大小为4个字节。变量作为程序中最基本的存储单元，其要素包括类型和作用域。变量在使用前必须、
对其声明，只有在变量声明以后，才能为其分配长度的存储空间。

1）变量声明格式：
           type varName [=vaule][,varName [=vaule]......] //[]中的内容为可选项，即可有可无
            int age = 19 , age2=20,age=30,........
数据类型   变量声明  [= 初始值 ] [,变量名  [=初始值] ......]；
 
2）变量的声明
	如果你只定义一个变量，没有给变量进行赋值的话，那么其实这个变量相当于变量没有定义；
	如果变量没有进行赋值，那么使用的时候回出错，告诉你：尚未初始化变量；
	反编译后发现声明和赋值被合成一句话了
	变量的名字随机分配了
	变量的值可以来回更改的。

3）变量的赋值




4）变量的使用
       一个变量不能重复定义




5）变量的内存
	内存只占用一块空间  
                 int age =18;





6）习题






7）变量的作用域：
作用域指的是就是作用范围，变量在什么范围中有
作用范围就是离它最近的{}



// 反汇编的命令 ：javap -v TestVar01.class   dos命令


							        三、整数型常常量

1.java是一种强类型语言，每个变量都必须声明其数据类型。
java的数据类型客以分为两大类：基本数据类型1（primtive,data,type）和引用数据类型（reference data type）.
                                                                          数据类型
                        基本数据类型                                                                       引用数据类
                           ||                                  				          ||
            数值型     ||   字符型（char） ||     布尔型 (boolean)              |||类 (class)  || 接口(interface)           ||  数组 
                         ||	
整数类型(byte,short,int,long) ||   浮点类型(float,double)

整数类型常量：
	十进制整数：99 ，
	八进制整数：015
	十六进制整数：0x15
	二进制整数：0b11




							        四、浮点类型常量
1.十进制数形式，例如：
3.14    314.0    0.314

2.科学计数法，如
314e    314E2(E大小写没有区分)   314E-2
double f = 314e2; //314*10^2-->31400.0
double f2 = 314e-2; //314*10^(-2) -->3.14



float 类型又称为作单精度类型，尾数可以精确到7位有效数字，在很多情况下，float 类型的精度很难满足需求。
而double 表示这种类型的数值精度约为float 类型的两倍，又称作双精度类型，绝大部分应用程序都采用double类型
float 类型的数值有一个后缀F或f，没有后缀F/f的浮点数值默认为doubel类型
也可以在浮点数值后添加后缀D或d，以明确其为double类型

类型         占用存储空间                  表数范围
float           4字节                     
doubel       8字节



PS:有效数字指的是从左开始第一个不为0的数到最后一个数




							        五、字符

1.什么是编码
 编码（计算机术语）
	编码是信息从一种形式或格式转换另一种形式的过程，也称为计算机编程语言的代码简称编码，用预先的规定的方法将
文字、数字、或其他对象编程数码，或信息、数据转换规定的电脉冲信号，编码在计算机、电视、遥控和通讯等方面
广泛使用。编码是信息从一中形式或格式转换为另一种形式的过程，解码，是编码的逆过程。
2.








3.由权威机构形成的编码表才可以称为：字符集
.ASCII
.IOS8859-1
.GB2312
.GBK
.Unicode



4.java中使用单引号来表示字符常量，字符型在内存占2个字节
char 类型用来表示在Unicode 编码表中的字符，Unicode编码被设计处理各种语言的文字，它占2个字节，可允许65536个字符，


5.转义字符：
\b      退格
\n       换行
\r        回车
\t        制表符
\"        双引号
\'         单引号
\\        反斜杠



6.基本类型布尔类型
boolean类型有两个常量值、true和false ，在内存中占一位（不是一个字节），不可以使用0和或非0的整数替代true和false ,这点与c语言不同
boolean 类型用来判断逻辑条件，一般用于程序流程。





6.基本数据类型转换
1）什么是数据类型转换：
	在赋值运算或者算数运算的时候，要求数据类型要达到一致，就要进行数据类型转换。

2）类型转换的种类：
	自由转换，强制转换

3内存演示

                                                          00001010 byte :10
00000000     00000000  00000000   00001010 int:10


00000000     00000000   00000000   00001110 int:270
                                                           00001110 byte:14


4)代码：
























7.final _字符常量
1）： 提取变量：一劳永逸
2）： 一个变量被final 修饰：这个变量变成一个常量，这个常量的值就不可变，就是字符常量。
约定俗称的规定：字符常量的名字必须全部大写。




									六、运算符

1.java语言支持如下的运算符：
(1).算数运算符
 +、-、*、/、%(取余)、++（自增）、--（自减）
+：1.表示一个正数，2.相加操作，3字符串相接
++： 无论这个变量是否参与到运算中去，只要用++ ，这个变量本身就加1操作
只是说如果变量参与到运算中去的话，对运算结果是产生结果影响：
看++ 再前还是再后，如果++再后：运算，后加1，如果++再前，先加1，后运算

--：同上（只是减1）

(2).赋值运算符
=：

的作用 ：将等号右侧的值赋给等号左侧的值

(3).扩展赋值运算符
+=，-=，*=，/=



(4).关系运算符
>,<,>=,<=,==,!=



(5).逻辑运算符
&& ,||, !,&,|,^
作用：进行逻辑运算，运算符左右连接的都是类型的操作数，最终表达式的结果式布尔值：要么是true ，要么false



(6).位运算符
&, |, ^,~， >> ，<<, >>>(了解！！！)

如何区分逻辑运算符和位运算符
逻辑运算符：左右连接的是布尔类型的操作

位运算符符：左右连接的具体的数值
[1]<< 左移
3 <<2 = 12
   00000000   00000000   00000000   00000011  --> 3
00000000   00000000   00000000   0000001100 --> 12
面试题： 4乘以8的最快方式： 4  <<3 = 32

[2] >> 右移
6 >> 2 = 1
00000000   00000000   00000000   00000110   --> 6
0000000000   00000000   00000000   00000110  --> 1

-6>>2= -2
00000000   00000000   00000000   00000110   --> 6 

取反：
11111111   11111111   11111111   11111001   -->   

加一：
11111111   11111111   11111111   11111010   -->-6


11111111   11111111   11111111   11111010       -->-6
1111111111   11111111   11111111   11111010   -->
1111111111   11111111   11111111   111110       -->    

减一：

1111111111   11111111   11111111   111101       -->
   
取反：
00000000000 00000000   00000000   000010       --> 2  
加负号：-->-2  

-6>>2=-2

[3] >>> 无符号右移

6  >>> 2 =1

00000000       00000000   00000000   00000110        -->6
0000000000   00000000   00000000       00000110    -->1



[4] & 与
6&3=2

6:  00000000       00000000   00000000   00000110 
       &
3:  00000000       00000000   00000000   00000011
_____________________________________________________________
     00000000       00000000   00000000   00000010 --> 2

[5]|或
6|3=7
6:  00000000       00000000   00000000   00000110 
       |
3:  00000000       00000000   00000000   00000011
_____________________________________________________________
     00000000       00000000   00000000   00000111  --> 7

[6]^ 异或
6^3=5
6:  00000000       00000000   00000000   00000110 
       ^
3:  00000000       00000000   00000000   00000011
_____________________________________________________________
     00000000       00000000   00000000   00000101  --> 5


[7]~反：
~6= -7
6:         00000000       00000000   00000000   00000110  
取反:    11111111       11111111   11111111   11111001  
减一：  11111111       11111111   11111111   11111000
取反:     00000000       00000000   00000000   00000111      --->7  
加符号：-7   




PS: byte类型的表数范围的 -128是怎样算出来的
127： 01111111
-128:  10000000
减一： 01111111
取反： 10000000   -->2^7 =128
加负号：-128



(7).条件运算符(三元运算符/三目运算符)
? :

a?b:c

其中a是一个布尔类型的表达式，返回结果要么是true,要么是false,通过a的结果决定最终表达式的结果
如果a的结果是true，那么表达式最终结果为b
如果a的结果是false ,要么表达式最终结果为c


if else 可以代替 三目运算符



8.运算符的优先级

单目>算术>关系>逻辑>三目>赋值

案列： 5<6 | 'A'>'a' && 12 * 6 <= 45 +23 &&!true
      =   5<6 | 'A'>'a' && 12 * 6 <= 45 +23 &&false
      =   5<6 | 'A'>'a' && 72<= 68 &&false
      =   true | false && false &&false
      =   true && false &&false
      =   false &&false
      =   false
二.概念

									第四章								

                                						          七、控制流程
1.流程控制的作用：
流程控制作用语句是用来控制程序中各语句，可以把语句组合成能完成一定功能的小逻辑模块

2.控制语句的分类：
控制语句分为三类：顺序、选择、循环
顺序结构，代表先执行a,再执行b，的逻辑。
条件结构,   代表 “如果”……，则“的逻辑。
循环结构，代表   ”如果……“   则再继续……”的逻辑。
三种流程控制语句就能表示所有的事情！不信，你可以试试拆分你遇到的各种事情。这三种基本逻辑结构是相互支撑的，它们共同构成了算法
的基本结构，无论怎样复杂的逻辑结构，都可以通过它们表达。所以任何一种高级语言都具备上述两种结构。

3.流程控制流程
顺序结构
分支结构
循环控制

一 if
[1]单分支
if(布尔表达式){
      语句块	
}

[2]多分支

if(  ){
}else if (){
}else(){
} 


[3]





[4]随机数
在java 中依靠一个类Math类帮助我们生成，这个类有一个方法专门用来生成随机数


[5]switch
switch( ){
     case * :....;	
     case * :....;
     ……
}
swith后面是一个（），（）中表达式返回结果是一个等值，这个等值的类型可以为：
int,byte,short,char,string,枚举类型

这个（）中的等值会依次跟case后面的值进行比较，如果匹配成功，就执行：后面的代码

为了防止代码的“穿透效果”：在每个分支后面加上一个关键字break,遇到break这个分支就结束

类似else的“兜底”“备胎” default:

default:可以写在任意位置，但是如果没有在最后一行，后面必须加关键字break,如果是最后一行，那么不需要加关键字。

相邻的分支，逻辑是一样的，那么就可以保留最后一个分支，上面的都可以省去不写

switch分支和if分支的差别：
如果表达式是等值判断的  ---> switch  if
如果表达式区间的判断的情况  ---> if 最好

switch应用场合：就是等值判断的情况下最多





[6]
while循环（作用：将部分代码重复执行）循环提高了程序员编写代码的效率，但是底层执行的时候依然使重复执行的。（先判断，后执行）
四要素：1.条件初始化，2.条件判断，3.循环体，4.迭代
初始化谁，就判断谁。判断谁，就迭代谁。
执行过程：1.2.3.4.  2.3.4   2.3.4.
while(){
   循环体;
}

在循环刚开始时，会计算一次“布尔表达式”的值，若条件为真，执行循环体，而对于后来每一次额外的循环，都会在开始前重新计算一次。
语句中应有使循环趋向于结束的语句，否则会出现无限循环----“死循环”


[7]do while(先执行,后判断) 
while(先判断，后执行)

什么场合使用do -while：

考试



[8]for
1.结构
for(条件初始化;条件判断;迭代){
	循环体;
}
2.i的作用域：离变量最近的{}
3.for循环格式特别灵活，不建议
4.for(;;){}---->死循环
   while(true){};---->死循环
   do {} while(true);---->死循环
5.循环分为两大类：
第一类：当型   while（）{}；  for(;;){}
第二类：直到型 do{} while();
6.常用：for(;;){}
7.do-while ,while,for 底层效率一样高


[9]break
在循环语句的主题部分，均可用break控制循环的流程，break用于强行退出循环，不执行循环中的语句。





[10]continue
continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定。






[11]return
return的作用，结束当前所在方法的执行



二重循环可以帮我解决：二元一次方程组的问题



									        五、方法的定义/调用/重载
1.什么是方法？
方法(method)就是一段用来完成特定动能的代码片段，类似于其它语言的函(fuction)
方法用于定义该类或类的实例的行为特征和功能实现，方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最基本单位，
整个单位，整个程序有一个个函数调用组成的，面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。

2.方法声明格式：
[修饰符1  修饰符2  .........] 返回值类型      方法名(形式参数列表){
	java 语句； ..........   ............   ...........
}

3.方法的调用方式
对象名.方法名(实参列表)


4.方法的详细说明
.形式参数：在方法声明时用于接收外界传入的数据
.实参：调用方法时实际传给方法的数据
.返回值：方法在执行完毕后返回给调用它的环境的数据。
.返回值类型：事先约定的返回值的数据类型，如无返回值，必须显示指定为为void


5.总结方法定义的格式
1）修饰符：暂停使用 public static ---> 面向对象
2）方法返回值类型：方法的返回值对应的数据类型
      数据类型：可以是基本数据类型（byte ,short,int,long,double,char,boolean）也可以是引用数据类型
3）方法名：见名知意，首字母小写，其余遵循驼峰式命名，eg:addNum,
4)  形参列表：方法定义的时候需要的形式参数： int num1, int num2 -->相当于告诉方法的调用者：需要传几个参数，需要传入的参数的类型
     实际参数：方法调用的时候传入的具体参数：10，20 ---> 根据形式参数的需要传入的

5）方法体：具体的业务逻辑代码
6)  return 方法返回值
方法如果有返回值的话：return+方法返回值，将返回值返回方法的调用处
方法没有返回值的话：

6.方法的定义需要注意什么：
1）形参列表要怎样写：定义几个参数，分别是什么类型的 --》不确定因素我们会当做方法的形参
2）方法到底是否需要返回值，如果需要的话，返回的类型是什么


7.方法的调用：
1）实际参数要怎样传入：传入几个参数，传入什么类型的
2)  方法是否有返回值需要接受



1.什么是方法的重载
方法的重载是指一个类中可以定义多个方法名相同，但参数不同的方法，调用时，会根据不同的参数自动匹配对应的方法。

注意本质：重载的方法，实际是完全不同的方法，只是名称相同而已。

2.构成方法重载的方法的条件：
*不同含义：形参不同、形参个数不同、形参顺序不同
*只有返回值不同不构成方法的重载
如：int a(String str){} 与 void a(String str ){} 不构成方法重载
*只有形参的名称不同，不构成方法的重载
如：int a (String str){} 与 int a (String s){} 不构成方法的的重载




总结： 
1.方法的重载：在同一个类中，方法名相同，形参列表不同的多个方法，构成了方法的重载。
2.方法的重载只跟：方法名和形参列表有关，与其他无关
3.注意：形参列表不同：

1.）    个数不同
add()
add(int num1)
add(int num1,int num2)
2.）    顺序不同
add(int num1,double num2)
add(double num1,int num2)

3.）    类型不同
add(int num1){}
add(double num1){}

4.请下面的的方法是否构成方法的重载？
(1) add(int a) 和 add(int b) --->no,相当于方法的重复定义
(2) public static int add(int a)和 public static void add(int b) ---> no





									      六、数组



1.定义：
数组是相同类型数据的有序集合。数组描述的是相同类型的若干个数据，按照一定的先后次序排列组合而成。其中，每一一个数据称作一个元素，每个
元索可以通过一个索引(下标)来访问它们。
数组的四个基本特点: 
1.长度是确定的。数组-旦被创建，它的大小就是不可以改变的。
2.其元索的类型必须是相同类型，不允许出现混合类型。
3.数组类型可以是任何数据类型，包括基本类型和引用类型。从0开始，到length-1结束
4.数组变量属于引用类型，数组也是对象。
PS:数组变量属于引用类型，数组也是对象，数组中的每个元索相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无
论保存原始类型还是其他对象类型，数组对象本身是在堆中存储的。


2.数组的作用：数组用来存储数据的，在程序设计中，为了处理方便，数组用来将相同的类型的若干数据组织起来。
这个若干数据的集合我们称为数组


3.数组有默认的初始化值，要看是什么类型的数组：
基本数据类型:
byte[] :0
short[]:0
int[]:0
long[]:0
float[]:0.0
double[]:0.0
char():"\u0000"
boolean():false


引用数据类型（null）
String()


4.数组的初始化方式总共有三种:静态初始化、动态初始化、默认初始化。
●静态初始化
除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。
数组的初始化方式总共有三种:静态初始化、动态初始化、默认初始化。
●静态初始化
除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。
eg:
int[] arr = {12,23,45};
int[] arr = new int[]{12,23,45};
注意:

1. new int[3]{12,23,45};-->出错 改为new int[]{12,23,45};
2.int [] arr;
arr = {12,23,34}--》出错

●动态初始化

数组定义与为数组元索分配空间并赋值的操作分开进行。
eg:
int[] arr = new int[3];
arr[0] = 12;
arr[1] = 23;
arr[2] = 45;
●默认初始化
数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变品同样的方式被隐式初始化。


int [] arr = new int[3]; --> 数组有默认初始化值


最值问题：
.方法的实参传递给形参的时候一定要注意：一切都是值传递
如果是基本数据类型，那么传递的就是字面值
如果是引用数据类型，那么传递就是地址值


查询问题：
1.查询指定位置的元素



2.查询指定元素的位置



二、main方法
[1] main方法:程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口
[2] main方法格式严格要求:
public static void main(String[] args){}
public static -->修饰符，暂时用这个-->面向对象-章
void -->代表方法没有返回值对应的类型void
main ---见名知意名字
String[] args -->形参--》不确定因素

[3]问题:程序中是否可以有其他的方法也叫main方法?
可以，构成了方法的重载。
1. public class Tes tArray10 {
2.	public static void main(String[] args) {
[1] main方法:程序的入口，在同一个类中，如果有多个方法，那么虚拟机就会识别main方法，从这个方法作为程序的入口
[2] main方法格式严格要求:
public static void main(String[] args){}
public static -->修饰符，暂时用这个-->面向对象-章
void -->代表方法没有返回值对应的类型void
main ---见名知意名字
String[] args -->形参--》不确定因素
[3]问题:程序中是否可以有其他的方法也叫main方法?
可以，构成了方法的重载。
1. public class Tes tArray10 {
2.
3.	public static void main(String[] args) {
4.
5.	}
6.	public static void main(String str) {
7.
8. 	}


[4]形参为String[那么实参到底是什么?
public class TestArray10{
	public static void main(String[] args) {
		//从侧面验证:
		//int[] arrl; //如果对数组只声明，没有后续操作，那么相当于白定义了。
		//int[] arr2 = null;
		/ /System. out .println (arr2. length) ;//Exception in thread "main" java. lang . NullPointerExc
eption
		//int[] arr3 =new int[0];

		/ /System. out.print1n (arr3. length) ;
		/ /int[] arr4 = new int[4];
		/ /System. out.print1n (arr4. length) ;
		/ /System. out.println (args. length) ;//0
		//从这个结果证明，参数是string[],实参是new string[0]
		//默认情况下，虚拟机在调用main方法的时候就是传入了一一个长度为0的数组
		System. out . println (args. length) ;
		for (String str:args) {
			System. out.println(str) ;
		}
	}
}

手动输入实参：
有特殊符号的可以加上 “字符串”

没有特殊符号的用空格隔开即可：




三、可变参数：
/*
	1.可变参数：作用提供了一个方法，参数的个数是可变得
	int ...num
	double ...num
	boolean...num
	作用：解决了部分方法的重载问题
	
	
	
	
	2.可变参数在JDk1.5之后加入了特性
	
	3.方法内部对可变参数的处理跟数组是一样的：
	
	4.可变参数和其它数据一起作为参数的时候，可变参数一定要放在最后
	
	5.建议不是用可变参数
*/
四、arry工具类的使用














五、数组的复制

System类的方法：
src  -->源数组
srcPos-->源数组中的起始位置
dest-->目标数组
destPos-->目标数组中的起始位置
length-->要复制数组元素的数量
可以随意复制目标数组的长度，任意位置开始和结束


六、二维数组的定义和遍历
int[] arr;  定义了一个数组，名字叫arr, 堆空间中每个“格子”中放入的数据都是int类型的。
doublel[] arr; 定义了一个数组，名字叫arr, 堆空间中每个"格子”中放入的数据都是double类型的。
boolean[ arr;定义了-个数组，名字叫arr,堆空间中每个"格子” 中放入的数据都是boolean类型的。


int[]] arr;定义了一个数组，名字叫arr,堆空间中每个"格子”中放入的数据都是int[]类型的


七、二维数组的初始化方式：
数组的初始化方式总共有三种:静态初始化、动态初始化、默认初始化。

●静态初始化
除了用new关键字来产生数组以外，还可以直接在定义数组的同时就为数组元素分配空间并赋值。
eg:
int[][] arr = {1,2),[4,5,6,{4,5,6,7,8,9,9);
int[][] arr =new int[][] {{1,2},{4,5,6),{4,5,6,7,8,9,9}}; 




●动态初始化
数组定义与为数组元素分配空间并赋值的操作分开进行。
eg:
int[]] arr = new int[3][]; //本质上定义了一-维数组长度为3,每个"格子”中放入的是一个数组
arr[0] = {1,2};
arr[1] = {3,4,5}
arr[2] = {6,7,8}


eg:
int [][] arr= new int[3] [2];//本质上定义一维数组，长度为3，每个数组“格子”中，有一个默认的长度为2的数组：




●默认初始化
数组是引用类型，它的元素相当于类的实例变量，因此数组-经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化。



八、Idea的使用












































九、面向对象
9.1

面向过程:当事件比较简单的时候，利用面向过程，注重的是事件的具体的步骤/过程，注重的是过程中的具体的行为，以函数为最小单位，考虑
怎么做。

面向对象:注重找“参与者" ,将功能封装进对象，强调具备了功能的对象，以类/对象为最小单位，考虑谁来做。
案例：人把大象装进冰箱
面向过程：
函数1:打开冰箱(){人站在冰箱前,打开冰箱,冰箱开到30度角的时候,冰箱灯打开了,.........}
函数2:储存大象(){大象先迈进左腿,再迈右腿,考虑冰箱能不能装下,......}
函数3:关闭冰箱(){人站在冰箱前,关闭冰箱,冰箱门关闭时,冰箱的灯关闭了,,,}

面向对象:
人{
  打开(冰箱){
    冰箱.打开();

}

  存储(大象){
    大象.进入();


}

  关闭(冰箱){
    冰箱.关闭();
    
}

  

}

冰箱{
  打开(){}

  关闭(){}
}

大象{
  进入(冰箱){}

 

}
面向过程-->面向对象,其实就是由执行者-->指挥者的-个过渡

二者相辅相成，并不是对立的。解决复杂问题,通过面向对象方式便于我们从宏观上把握事物之间复杂的关系、方便我们分析整个系统;具体到微观操
作仍然使用面向过程方式来处理


9.2类和对象

9.2.1
  万事万物皆对象

9.2.2
对象：具体的事物，具体的实体，模板下具体的产品
类：对对象向上抽取出象的部分，形成类，类是抽象的，是一个模板

9.2.3
一般写代码得时候先写类，然后在根据类创建对象。


9.3面向对象的三个阶段
9.3.1面向对象分析OOA -- Object Oriented Analysis
对象：张三、王五、你、我
抽取出一个类 --->人类

类里面有什么：
动词：动态特性-->方法
名词：静态特性-->属性

9.3.2面向对象设计OOD -- Object Oriented Design
先有类，再有对象
类：人类：Person
对象：张三、李四

9.3.3面向对象编程OOP -- Object  Oriented Programming


9.4面向对象_创建类
9.4.1属性(field成员变量)
属性用于定女该类或该类对象包含的数据或者说静态特征。属性作用范围是整个类体。
属性定义格式:
[修饰符]属性类型属性名= [默认值];

9.4.2方法
方法用于定义该类
或该类实例的行为特征和功能实现。方法是类和对象行为特征的抽象。方法很类似于面向过程中的函数。面向过程中，函数是最
基本单位，整个程序由一一个个函数调用组成。面向对象中，整个程序的基本单位是类，方法是从属于类和对象的。

方法定义格式:
[修饰符]方法返回值类型方法名(形参列表) {
	// n条语句
}
void代表没有返回值:方法的作用:重用代码，封装功能，便于修改





9.5创建对象



























9.6局部变量和成员变量的区别
区别1:代码中位置不同
	成员变量:类中方法外定义的变量
	局部变量:方法中定义的变量代码块中定 义的变量

区别2:代码的作用范围
	成员变量:当前类的很多方法
	局部变量:当前一个方法(当前代码块)

		
区别3:是否有默认值
	成员变量:有
	局部变量:没有

基本类型                       默认值
   boolean                       Flase
    char                            lu0000’(nul)
    byte                           (byte)0
    short                         (short)0
    int                               0
    long                            OL
   float                             0.0f
  double                          0.0d
引用数据类型：null
区别4:是否要初始化
	成员变量:不需要，不建议初始化，后续使用的时候在赋值即可
	局部变量:一定需要，不然直接使用会报错

区别5:内存中位置不同
  	成员变量：堆内存
	局部变量：栈内存

区别六：作用时间不同
	成员变量：当前对象从创建到销毁
	局部变量：当前方法从开始到执行完毕





9.7面向对象-构造器

package com.object2;

public class Person {
    //构造器：没有任何参数的构造器我们叫做：空惨构造器-->空构造器
    public Person(){
       /*name = "lili";//name:null
        age = 19;//age:0
       height = 169.5;//height:0.0*/
    }
    //属性：
    String name;//name:null
    int age;//age:0
    double height;//height:0.0

    //方法
    public void eat(){
        System.out.println("我喜欢吃饭");
    }
}





package com.object2;

public class Test {
    public static void main(String[] args) {
        //创建一个Person类的具体的对象/实体


        //创建对象的过程：
        /*
        * 1.第一次遇到Person的时候】【，进行类的加载（只加载一次）
        * 2.创建对象，为这个对象在堆里开辟空间
        * 3.为对象的属性进行赋值
        *
        * new 关键字实际上是在调用一个方法，这个方法叫做构造方法(构造器)
        可是自己显式，隐式
       [修饰符]构造器的名字(){

       }
       构造器和方法的区别：
       1.没有方法的返回值类型
       2.方法体内部不能return语句
       3.构造器的名字很特殊，必须跟类名一样
        *
        *
       构造器的作用：不是为了创建对象，因为在调用构造器之前，这个对象就已经创建好了，并且属性有默认的初始化值。
       调用构造器的目的是给属性进行赋值操作的。

        *
        注意：我们一般不会在空构造器中进行初始化操作，因为那样的话每个对象的属性就一样。
        */
        Person p = new Person();
        System.out.println(p.name);
        System.out.println(p.age);
        System.out.println(p.height);

        Person p1 = new Person();
        System.out.println(p1.name);
        System.out.println(p1.age);
        System.out.println(p1.height);

    }
}















9.8构造器的重载

package com.object3;

public class Person {

    //属性
    String name;
    int age;
    double height;

    //空构造器
    public Person(){

    }

    public Person(String name, int age, double height){
        //当形参名字和属性名字重名的时候，程序出现就近原则。解决方法，在属性名字前加关键字this.
        //在要表示对象的属性前加上this.来修饰,因为this代表的就是你创建的那个对象
        this.name = name;
        this.age = age;
        this.height = height;
    }

    public Person(String name, int age){
        this.name = name;
        this.age = age;
    }

    //方法
    public void eat(){
        System.out.println("我喜欢吃饭");
    }
}



package com.object3;

public class Test {
    //这是程序的入口
    public static void main(String[] args) {
        /*
        1.一般保证空构造器的存在，空构造器一般不会进行赋值操作
        2.一般我们重载构造器，在重载构造器中进行属性赋值操作
        3.假如在重载构造器以后，假如空构造器忘写了,系统也不会给你分配默认的空构造器了，那么你要调用的话就会出错了



        */
        Person p = new Person();

        /*name = "lili";//name:null
        age = 19;//age:0
        height = 169.5;//height:0.0*/

        Person p2 = new Person("lili",19,188.4);
        System.out.println(p2.name);
        System.out.println(p2.age);
        System.out.println(p2.height);


    }
}




9.9内存分析
9.9.1
public class Person{
	int  id;
	int age;

	public static void main(String args[]){
		Person p1 = new Person();
	}



}


9.9.2
public class Person {
	int id;
	int age;
	String school;

	public Person (int a, int b, String c,){
		id = a;
		age = b;
		school = c;


	}
	public static void main(String args[]){
		Person p = new Person(1,2,"xxx");
	
	}


}




9.9.3
class Person{
	int id;
	int age;
	String school;
	
	public (int a, int b, String c){
		id = a;
		age = b;
		school = c;



	}
	
	public void setAge(int a){
		age = a;
	
	}

}


public class Test{
	public static void main(String[] args){
		Test t = new Test();
		int age = 40;
		Person tom = new Person(1,20,"xxx");
		Person jack = new Person(2,30,"xxx");
		t.change1(age);
		t.change2(tom);
		t.change3(jack);
		System.out.println(age);
		System.out.println("id:"+ jack.id + ",age:" +jack.age +",shcool" +"jack.shcool");
	}
		
		public void change1(int i){
			i =3366;
		}
		
		public void change2(Person p){
			p = new Person(3,22,"xxx");
		}
		public void change3(Person p){
			p.setAge(66);
		}
}



10.面向对象

10.1this使用
this：指代的就是当前对象

用法：
(1)this可以修饰属性
当属性名字和形参发生重名的时候，或者 属性名字 和局部变量重名的时候，都会发生就近原则，所以如果我要直接使用变量的名字的话
就指的是离得近那个形参和局部变量，这时候如果我想要表示属性的话，在前面加上：this修饰

如果：不发生重命名问题，访问属性，this可以省略不写




(2)this修饰方法：
总结：在同一类中，方法可以互相调用，this可以省略不写




(3)this可以修饰构造器
使用方法：
总结：同一个类中的构造器可以相互this调用，注意：this修饰构造器必须放在第一行，不然会报错




10.2staitc修饰属性

10.2.1static 可以修饰：属性、方法、代码块、内部类。不能修饰构造器、

10.2.2static 
package com.object5;

public class Test {

    //属性：
    int id;
    static int sid;


    //这是一个main方法，这是程序的入口
    public static void main(String[] args) {
            //创建一个Test类的具体的对象
            Test t1 = new Test();
            t1.id = 10;
            t1.sid = 10;

            Test t2 = new Test();
            t2.id = 20;
            t2.sid = 20;

            Test t3 = new Test();
            t3.id = 30;
            t3.sid = 30;

            //读取属性的值
            System.out.println(t1.id);
            System.out.println(t2.id);
            System.out.println(t3.id);

            System.out.println(t1.sid);
            System.out.println(t2.sid);
            System.out.println(t3.sid);
    }
}


内存分析：



一般官方的推荐访问方式，可以通过类名.属性名的方式访问：
Test.sid = 100;
System.out.println(Test.sid);


Static修饰属性总结
(1)在类加载的时候一起加载方法区中的静态域中
(2)先于对象存在
(3)访问方式：对象名.属性名   类名.属性名(推荐)

static修饰属性应用场景：某些特定的数据想要在内存中共享，只有一块 -->这个情况下，就可以用static修饰的属性。

package com.object5;

public class Student {
    //属性：
    String name;
    int age;
    static String school;

    //这是一个main方法，是程序的入口:
    public static void main(String[] args) {
            Student.school = "信息学院";

            //创建学生对象
            Student s1 = new Student();
            s1.name = "张三";
            s1.age = 19;
            //s1.school = "信息学院";

            Student s2 = new Student();
            s2.name = "李四";
            s2.age = 21;
            //s2.school = "信息学院";


            System.out.println(s2.school);
    }
}

属性：
静态属性：(类变量)
非静态属性:(实例变量)




10.2.3static修饰方法：

package com.object5;

public class Demo {
    int id;
    static int sid;

    public void a(){
        System.out.println(id);
        System.out.println(sid);
        System.out.println("----------a");
    }

    //1.static 和 public都是修饰符，并列的没有先后顺序，先写谁后写谁都行
    public static void b(){
        //System.out.println(this.id);//4在静态方法中不能访问和使用this
        //a();//3.在静态方法中不能访问非静态的方法
        //System.out.println(id);//2.在静态方法中不能访问非静态属性
        System.out.println(sid);
        System.out.println("-------b");
    }

    //这是一个main方法，这是程序的入口
    public static void main(String[] args) {
        //5.非静态的方法可以用对象名.方法名去调用
        Demo d = new Demo();
        d.a();

        //6.静态的方法可以,对象名.方法名去调用,也可以用类名.方法名调用
        Demo.b();
        d.b();
        
        //在同一个类中调用
        b();
    }
}



10.3代码块
10.3.1类的组成：属性，方法，构造器，代码块，内部类
10.3.2代码块分类：普通块，构造块，静态块，同步块(多线程)
10.3.3代码：
普通块：在方法中

package com.object6;

public class Test {
    //属性
    int a;
    static int sa;


    //方法
    public void a(){
        System.out.println("------a");
        //普通块
        {
            System.out.println("这是普通块");
            //普通块限制了局部变量作用范围
            System.out.println("----00000");
            int num = 10;
            System.out.println(num);
        }


    }

    public static void b(){
        System.out.println("------b");
    }

    //构造块
    {
        System.out.println("------这是构造快");
    }

    //静态块
    static{
        System.out.println("------这是静态块");
        //只能访问静态的属性和方法
        System.out.println(sa);
        b();
    }

    //构造器
    public Test(){

    }
    public Test(int a){
        this.a = a;
    }



    //代码块
    //这是一个main方法，是程序的入口
    public static void main(String[] args) {
            Test t = new Test();
            t.a();

            Test t2 = new Test();
            t2.a();
    }


}
总结：(1)代码块的执行顺序
最先执行静态块，只在类加载的时候执行一次，项目：数据库的初始化信息都放入静态块
一般用于执行一些全局性的初始化操作

再执行构造块，(不常用)
再执行构造器
再执行方法中的普通块



10.4import
10.4.1包的作用：
为了解决重名问题(实际上包对对应的就是盘符上的目录)
解决权限问题

10.4.2创建包：




10.4.3包名的定义
(1)名字全部小写
(2)中间用.隔开
(3)一般都是用公司域名倒着写：com.jd
(4)加上模块的名字：
com.jd.login
(5)不能使用系统的关键字：nul,con,com1-com9
(6)包声明的位置一般都在非注释性的代码第一行，



10.4.4导包问题

package com.object7;

import com.object7.Person;//导包:就是为了进行定位

import java.util.Date;


public class Test {

    public static void main(String[] args) {
        new Person();
        new Date();
        new java.sql.Date(1000L);//在导包以后，还想用其它包内下同名的类，就必须要手动自己写所在的包。
    }
}

总结：
(1)使用不同包下的类需要导包：import ***.****. 
(2)在导包以后，还想用其它包下同名的类，就必须要手动自己写在所在的包
(3)同一个包下的类想使用不需要导包，可以直接使用
(4)在java.lang包下的类，可以直接使用无需导包
	System.out.println(Math.random());
(5)Idea导包快捷键：alt+enter
可以实现自动导包：

(6):
//import java.util.*;//代表util所有的包


10.4.5在java中的导包没有包含和被包含的关系：
设置目录格式：平级格式不是包含和被包含的关系

静态导入：

package com.object11;

import static java.lang.Math.*;//导入 java.lang.Math类中的静态的内容。

public class Test {
    public static void main(String[] args) {
        System.out.println(Math.random());
        System.out.println(Math.PI);
        //System.out.println(Math.round(5.6));
        System.out.println(round(5.6));
    }
    //在静态导入后，同一个类中有相同的方法的hi后，会优先先走自己定义的方法。
    public static int round(double a){
        return 1000;
    }
}



10.5封装

10.5.1
[1]生活案例:

[2] Java中封装的理解:
将某些东西进行隐藏，然后提供相应的方式进行获取。
概念
      封装是把过程和数据包围起来，对数据的访问只能通过己定文的接口。面向对象计算始于这个基本概念，即现实世界可
以被描绘成一系列完全自治、 封装的对象，这些对象通过一一个受保护的接口访问其他对象。封装是一种信息隐藏技术，在
java中通过关键字private，protected和public实现封装。 什么是封装?封装把对象的所有组成部分组合在-起，封装定义程
序如何引用对象的数据，封装实际上使用方法将类的数据陷藏起来，控制用户对类的修改和访问数据的程度。适当的封装可
以让程式码更容易理解和维护，也加强了程式码的安全性。

我们程序设计追求"高内聚，低耦合"。
➢高内聚:类的内部数据操作细节自己完成，不允许外部干涉;
➢低耦合:仅对外暴露少量的方法用于使用。
隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提
高系统的可扩展性、可维护性。通俗的说，把该隐藏的隐藏起来，该暴露
的暴露出来。这就是封装性的设计思想。

[3]封装的好处:
提高代码的安全性







代码：
package com.object.test01;

public class Girl {

    //属性:
    private int age;

    //读取年龄：
    public int duquAge(){
        return age;
    }

    //设置年龄
    public void shezhiAge( int age){
        this.age = age;
    }

}


package com.object.test01;

public class Test {
    public static void main(String[] args) {

        Girl g = new Girl();


//      System.out.println();

        //设置年龄
        g.shezhiAge(31);


        //读取年龄
        System.out.println(g.duquAge());

    }
}

上面代码，对于属性age来说，我加了修饰符private,这样外界对它的访问就受到了限制，现在我还想加上其它的限制条件，但是在属性本身
上没有办法再加了，所以我们通过定义方法来进行限制条件的添加。
以属性为案列：
进行封装：
(1)将属性私有化，被private修饰--->加入权限修饰符
一旦加入权限修饰符，其他人就不可以随意的获取这个属性
(2)提供public 修饰的方法让别人来访问/使用
(3)即使外界可以通过方法来访问属性了，但是也不能随意访问，因为在方法中可以加入限制条件。


10.5.2
实际开发中，方法一般会写成 setter,getter
可以利用IEDA快捷键生成： alt+insert --> getter and setter

package com.object.test01;

public class Test {
    public static void main(String[] args) {

        Girl g = new Girl();


//      System.out.println();

        //设置年龄
        g.setAge(31);


        //读取年龄
        System.out.println(g.getAge());

    }
}



package com.object.test01;

public class Girl {

    //属性:
    private int age;
    private int sno;
    private String name;
    private double height;

    //读取年龄：
    public int getAge(){
        return age;
    }

    //设置年龄
    public void setAge( int age){
        if(age >= 30){
            this.age = 18;
        }else{
            this.age = age;
        }
    }

}



代码：

package com.object.test02;

public class Student {
    //属性:

    private int age;
    private String name;
    private String sex;

    //加入对应的setter 和getter方法
    public int getAge(){
        return age;
    }

    public void setAge(int age){
        this.age = age;
    }

    public String getName(){
        return name;
    }

    public void setName(String name){
        this.name = name;
    }

    public String getSex(){
        return sex;
    }

    public void setSex(String sex){
        if("男".equals(sex) || "女".equals(sex)){
            this.sex = sex;
        }else{
            this.sex = "男";
        }
    }
    //加入构造器
    public Student(){

    }
    public Student(int age,String name,String sex){
        this.age = age;
        this.name = name;
        //this.sex = sex;
        this.setSex(sex);
    }


}



package com.object.test02;

public class Test {

    public static void main(String[] args) {

        //创建一个Student对象
        Student s1 = new Student();
        s1.setName("nana");
        s1.setAge(19);
        s1.setSex("女");
        System.out.println(s1.getName()+ "---"+ s1.getAge()+"----"+s1.getSex());

        Student s2 = new Student(18,"菲菲","男");
        System.out.println(s2.getName()+ "---"+ s2.getAge()+"----"+s2.getSex());
    }
}


10.6继承
10.6.1类是对对象抽象：
举例：
荣耀20，华为，小米，vivo ---> 类：手机类

10.6.2继承是对类的抽象：
举例：
学生类：Student:
属性：姓名，年龄，身高，学生编号
方法：吃法，睡觉，学习，娱乐

教师类：Teacher
属性：姓名，年龄，身高，教师编号
方法：吃饭，睡觉，教学

员工类：Employee
属性：姓名，年龄，身高，员工编号
方法：吃法，睡觉，工作


学生类/教师类/员工类 继承类  自 人类
抽取共同的东西
人类：--》父类，基类，超类
属性：姓名，年龄，身高
方法：吃饭，睡觉


在定义--》子类，派生类

学生类：Student:
属性：学生编号
方法：学习，娱乐

教师类：Teacher
属性：教师编号
方法：教学

员工类：Employee
属性：员工编号
方法：工作




子类继承 父类

狗类：
属性：姓名，年龄，身高
方法：吃饭，睡觉

我们继承关系，在合理的范围进行抽取，抽出子类父类的关系
上面的案例：
学生类/教师类/员工类 继承类  自 人类： 合理
学生类/教师类/员工类 继承类  自 狗类： 不合理


总结：继承 就是 is- a的关系


代码层面的关系：
父类：人类
子类：学生

package com.object.test03;

public class Person {
    //属性
    private int age;
    private String name;
    private double height;


    //提供setter getter方法
    public int getAge(){
        return age;
    }

    public void setAge(int age){
        this.age = age;
    }

    public String getName(){
        return name;
    }

    public void setName(String  name){
        this.name = name;
    }

    public double getHeight(){
        return height;
    }

    public void setHeight(double  height){
        this.height = height;
    }



    //方法
    public void eat(){
        System.out.println("吃饭.....");
    }
    public void sleep(){
        System.out.println("睡觉");
    }

}


package com.object.test03;

public class Student extends Person {
    //属性
    private int sno;//学号：

    public int getSno(){
        return sno;
    }

    public void setSno(int sno){
        this.sno = sno;
    }

    //方法
    public void study(){
        System.out.println("学生可以学习");
    }

}


package com.object.test03;

public class Test {
    public static void main(String[] args) {
        //创建子类Student的对象
        Student s = new Student();
        s.setSno(1001);
        s.setAge(18);
        s.setName("xxx");
        s.setHeight(169.8);

        System.out.println("学生名字："+s.getName()+"\n" +"学生学号："+s.getSno()+"\n" +"学生年龄："+s.getAge()+"\n" +"学生身高："+s.getHeight());
        s.eat();
        s.sleep();
    }
}




继承的好处：提高代码的复用性
父类定义的内容，子类可以直接拿过来就可以了，不用代码
注意：
父类private修饰的内容，子类实际上也继承，只是因为封装的特性阻碍了直接调用，提供了间接调用

10.6.3总结：
(1)继承关系：
父类/基类/超类
子类/派生类
子类继承父类一定在合理的范围进行继承的   子类extends 父类

(2)继承的好处：
1.提高了代码的复用性，父类定义的内容，子类可以直接拿过来用就可以了，不用代码上反复重复定义
2.便于代码的扩展
3.为了以后多态的使用。是多态的前提

(3)父类private修饰的内容，子类也继承过来了。

(4)一个父类可以有多个子类
(5)一个子类只能继承一个直接父类
(6)继承具有传递性
student--> 继承Person -->继承自Object
Object类是所有类的根基父类
所有的类直接或者间接继承自Object。


  
10.7权限修饰符
	同一个类               同一个包                     子类           所有类
private        *                   
default        *                             *
protected   *                             *                             *
public         *                             *                             *                   *

10.7.1private


package com.object.test05;

public class Test {

    public static void main(String[] args) {
        A a= new A();
        a.age = 10;//报错
    }
}

package com.object.test05;

public class A {
    private int age;
    public void eat(){
        System.out.println(age);
        age = 10;
    }
}




10.7.2default:缺省





10.7.3protected ：
package com.object.test05;

public class A {
    protected int age;
    public void eat(){
        System.out.println(age);
        age = 10;
    }
}

package com.object.test06;

import com.object.test05.A;

public class B extends A {
    public void a(){

        System.out.println(age);
    }
}



10.7.4public：在整个项目都可以访问


总结：
属性，方法：修饰符：四种：private,defalut,protected,public
类：修饰符：两种：defalut,public




10.8方法的重写
10.8.1重写
发生在子类和父类中，当子类对父类提供的方法不满意的时候，要对父类的方法进行重写。

10.8.2重写由严格的格式要求：
子类的方法名字和父类必须一致，参数列表（个数、类型、顺序）也要和父类一致


10.8.3
package com.object.test04;

public class Student extends Person{
    public void study(){
        System.out.println("学习");
    }
    public void eat(){
        System.out.println("我喜欢吃火锅");
    }
}


package com.object.test04;

public class Test {
    public static void main(String[] args) {
        //创建一个Student类的对象
        Student s = new Student();
        s.eat();
        s.sleep();
    }
}


10.8.4 内存










10.8.5重载和重写的区别
重载：在同一个类中，当方法名相同，形参列表不同的时候，多个方法构成了重载。
重写：在不同的类中，子类对父类提供的方法不满意，要对父类的方法进行重写。

	英文           位置不同                           修饰符                                    返回值                                   方法名                    参数                  抛出异常              方法体      
重载       overload      同一个类中                         无关                                        无关                                   必须相同               必须不同                无关                     不同                                                           
重写       override      子类和父类中     父类的权限修饰符要低于子类的       父类的返回值类型大于子类            必须相同               必须相同             小于等于                  不同               





10.9  super修饰属性
10.9.1super指的是：父类的

10.9.2 
super可以修饰属性，可以修饰方法
在子类的方法中，可以通过super.属性  super.方法的方式，显示的去调用父类提供的属性，方法。
在通常下，super可以省略不写。

package com.object.test07;

public class Student extends Person{
    double score;

    public void study(){
        System.out.println("我......");
    }
    public void a(){
        System.out.println(super.age);
        super.eat();
    }
}



在特殊情况下，当子类和父类属性重名时，你要想使用父类的属性，那么必须加上修饰符super
package com.object.test07;

public class Student extends Person{
    double score;
    int age = 20;
    public void study(){
        System.out.println("我......");
    }
    public void eat(){
        System.out.println("我......");
    }
    public void a(){
        System.out.println(age);
        System.out.println(this.age);
        System.out.println(super.age);
        eat();
        this.eat();
        super.eat();
    }
}


10.9.3修饰构造器
平时写的空构造器的第一行都有:super(); ---> 作用：调用父类的空构造器，只是我们一般省略不写

package com.object.test08;

public class Student extends Person{
    double score;

    public Student(){
       /* super();*/
    }

}


如果构造器中已经显示的调用Super父类构造器，那么它的第一行就没有默认分配的super();
(所有构造器的第一行默认情况下都有super(),但是一旦你的构造器中显示的使用super调用父类构造器，
那么这个super()就不会给你默认的分配了,如果构造器中没有显示的调用父类构造器的话，那么第一行都有
super(),可以省略不写）

    public Student(int age,String name,double score){
        //super();
        /*this.name = name;
        this.age = age;*/
       /* super.name = name;
        super.age = age;*/
        super(age,name);//利用Super调用父类构造器
        this.score = score;
    }



在构造器中，super调用父类构造器和this调用子类构造器，只能存在一个，两者不能共存
因为super修饰构造器要放在第一行，this修饰构造器也要放在第一行。
        public Student(int age,String name,double score){
               super(age,name);//利用Super调用父类构造器
               this(score);
               //super();
               /*this.name = name;
               this.age = age;*/
               /* super.name = name;
               super.age = age;*/
  } 
解决方法：二选一。


10.9.4以后代码构造器的生成可以直接使用IDEA快捷键  ：alt+insert











11
11.1继承条件下构造方法的执行过程
package com.object.test10;

public class Student extends Person{
    double height;

    public Student() {

    }

    public Student(int age, String name, double height) {
        super(age,name);
        this.height = height;
    }
}


11.2 Object类
所有类都直接或间接的继承自Object类，Object类是所有Java类的根基类。
也就意味着所有的Java对象都拥有Object类的属性和方法。
如果在类的声明中未使用extends关键字指明其父类，则默认继承Object类。

11.2.1Object类toString方法
作用：


原理：
getClass().getName()+                       '@'  + Integer.toHexString(hashCode())
com.object.test01.Student                  @      7f31245a
全限定路径：包名+类名的完整表达                 hashCode()-->将对象在堆中的地址，进行哈希算法，返回一个码-->哈希码，将这个哈希码传到Integer.toHexString(哈希码);  
				      这个字符串一个十六进制的数对应的字符串，对象-->堆中分配地址-->进行哈希码-->转成16进制-->String
toString()打印出不友好

package com.object.test01;

public class Test {
    public static void main(String[] args) {
        //创建一个Student类的具体实例
        Student s = new Student("lili",19,162.6);
        System.out.println(s);//com.object.test01.Student@7f31245a
        System.out.println(s.toString());//public class Test {


    }
}

问题：子类Student对父类Object提供的toString()方法不满意，不满意-->对Student重写

  public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                ", height=" + height +
                '}';
    }


11.3Object类的equals方法(1)
代码：

package com.object.test02;

public class Phone {//手机类
    //属性：
    private String brand;//品牌型号
    private double prise;//价格
    private int year;//出场年份

    //方法

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public double getPrise() {
        return prise;
    }

    public void setPrise(double prise) {
        this.prise = prise;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    //构造器

    public Phone() {

    }

    public Phone(String brand, double prise, int year) {
        this.brand = brand;
        this.prise = prise;
        this.year = year;
    }


    @Override
    public String toString() {
        return "Phone{" +
                "brand='" + brand + '\'' +
                ", prise=" + prise +
                ", year=" + year +
                '}';
    }

    //对equals方法进行重写：
    public boolean equals(Object obj){
        //将obj转为Phone类型
        Phone other = (Phone)obj;//??
        if(this.getBrand() == other.getBrand() && this.getPrise()==other.getPrise() && this.getYear() == other.getYear()){
            return true;
        }
        return false;
    }
}


package com.object.test02;

public class Test {
    public static void main(String[] args) {
        //创建Phone类的对象
        Phone p1 = new Phone("华为P40",1999.9,2008-8-10);
        Phone p2 = new Phone("华为P40",1999.9,2008-8-10);

        //比较两个对象：p1和p2对象
        //==的作用：比较左右两侧的值是否想的，要么相等，返回true,要么不相等,返回false
        System.out.println(p1==p2);//-->对于引用数据类型来说，比较的不是地址值

        //Object类提供了一个方法equals方法：作用：比较对象具体内容是否相等。
        boolean flag = p1.equals(p2);//依旧是==
        System.out.println(flag);//false

    }
}



总结：
equals作用：提供了对象的内容是否相等，的一个比较方式，对象的内容指的就是属性。
父类Object提供的equlas就是在比较 == 地址，没有实际的意义，我们一般不会直接使用父类
提供的方法，而是在子类对方法进行重写。



11.4Object类的equals方法(2)_instanceof
package com.object.test02;

public class Phone {//手机类
    //属性：
    private String brand;//品牌型号
    private double prise;//价格
    private int year;//出场年份

    //方法

    public String getBrand() {
        return brand;
    }

    public void setBrand(String brand) {
        this.brand = brand;
    }

    public double getPrise() {
        return prise;
    }

    public void setPrise(double prise) {
        this.prise = prise;
    }

    public int getYear() {
        return year;
    }

    public void setYear(int year) {
        this.year = year;
    }

    //构造器

    public Phone() {

    }

    public Phone(String brand, double prise, int year) {
        this.brand = brand;
        this.prise = prise;
        this.year = year;
    }


    @Override
    public String toString() {
        return "Phone{" +
                "brand='" + brand + '\'' +
                ", prise=" + prise +
                ", year=" + year +
                '}';
    }

    //对equals方法进行重写：
    public boolean equals(Object obj){
        /*
        *instanceof 运算符:
        * a instanceof b
        * 判断a对象是否b这个类的实例，如果是 返回true    如果不是发挥false
        */
        if(obj instanceof Phone){//属于Phone类的对象
            //将obj转为Phone类型
            Phone other = (Phone)obj;//??
            if(this.getBrand() == other.getBrand() && this.getPrise()==other.getPrise() && this.getYear() == other.getYear()){
                return true;
            }

        }
        return false;
    }
}




11.5Object类的equals方法(3)
利用eclipse:
	public boolean equals(Object obj) {
		if (this == obj)
			return true;
		if (obj == null)
			return false;
		if (getClass() != obj.getClass())
			return false;
		TestObject01 other = (TestObject01) obj;
		if (brand == null) {
			if (other.brand != null)
				return false;
		} else if (!brand.equals(other.brand))
			return false;
		if (Double.doubleToLongBits(price) != Double.doubleToLongBits(other.price))
			return false;
		if (year != other.year)
			return false;
		return true;
	}











利用IDEA:
1.
   public boolean equals(Object obj){
        /*
        *instanceof 运算符:
        * a instanceof b
        * 判断a对象是否b这个类的实例，如果是 返回true    如果不是发挥false
        */
        if(obj instanceof Phone){//属于Phone类的对象
            //将obj转为Phone类型
            Phone other = (Phone)obj;//??
            if(this.getBrand() == other.getBrand() && this.getPrise()==other.getPrise() && this.getYear() == other.getYear()){
                return true;
            }

        }
        return false;
    }

2.
  public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Phone phone = (Phone) o;
        return Double.compare(phone.prise, prise) == 0 &&
                year == phone.year &&
                Objects.equals(brand, phone.brand);
    }


11.6类和类之间的关系(1)
11.6.1.面向对象的：找参与者，找类
11.6.2.方法的形参，方法的实参

    public void love(Boy b){//引用数据类型
        System.out.println("名字"+ b.name +",年龄"+ b.age );
        b.boy();
    }
Boy b 方法的形参



、
public static void main(String[] args) {
        //一个创建Boy类的具体的对象
        Boy boy = new Boy(30,"xxx");
        //创建一个Girl类的具体的对象
        Girl girl = new Girl("xxx",100);

        //

        girl.love(boy);
    }
具体传入的内容 实参：boy



11.6.3类和类可以产生关系
将一个类作为另一个类的方法的形参
将一个类作为另一个类的属性

package com.object.test03;

public class Test {
    public static void main(String[] args) {
        //一个创建Boy类的具体的对象
        Boy boy = new Boy(30,"xxx");
        //创建一个Girl类的具体的对象
        Girl girl = new Girl("xxx",100);

        //

        girl.love(boy);

        Boy boy2 = new Boy(35,"xx");

        girl.love(boy2);

        //微信聊天
        girl.m = new Mom();
        girl.wechat();

    }
}



package com.object.test03;

public class Girl {
    //属性:
    String name;
    double weight;
    Mom m;/*= new Mom();*/

    //方法:

    public void add(int a){
        System.out.println(a);
        System.out.println(a+100);
    }
    public void love(Boy b){//引用数据类型
        System.out.println("名字"+ b.name +",年龄"+ b.age );
        b.boy();
    }

    //女孩跟妈妈聊天
    public void wechat(){
        m.say();
        System.out.println(weight);
    }


    //构造器
    public Girl(String name, double weight) {
        this.name = name;
        this.weight = weight;
    }
}



11.7类和类之间的关系(2)
11.7.1







11.8多态
(多态属性无关，多态指的是方法的多态，而不是属性的多态)
11.8.1     

package com.object.test01;

public class Animal {//父类：动物
    public void shout(){
        System.out.println("我是小动物，我可以叫.....");
    }
}


package com.object.test01;

public class Cat extends Animal{
    //猫叫的方法
    public void shout(){
        System.out.println("我是小猫，我可以喵喵");
    }

    public void scratch(){
        System.out.println("猫咪挠人");
    }
}


package com.object.test01;

public class Test {
    public static void main(String[] args) {
        //具体的女孩：-->女孩的对象
        Girl g = new Girl();

       /* //具体的猫：-->猫的对象
        Cat c = new Cat();

        //具体的狗：-->狗的对象
        Dog d = new Dog();

        //小女孩跟猫玩耍
        g.play(c);

        //小女孩跟狗玩耍
        g.play(d);*/

        //具体的动物：-->动物的对象
       /* Cat c = new Cat();
        Animal an = c;*/
        Pig p1 = new Pig();
        Animal an = p1;
        g.play(an);
    }
}

总结：
(1)现有父类，再有子类，是继承
(2)现有子类，后引出父类，是泛华
(3)什么是多态:
多态就是多种状态：同一个行为，不同的子类表现出来不同的形态
多态指的是就是同一个方法调用，然后由于对象不同会产生不同的行为。

(4)多态的好处
为了提高代码的扩展性，符合面向对象的设计原则：开闭原则。
开闭原则：指的就是扩展时开放，修改时关闭。
注意：多态可以提高扩展性，但扩展性没有达到最好，而反射可以。
(5)多态的要素：
1、继承：Cat extends Animal
2、重写：子类对父类方法的重写、
3、父类：引用指向子类对象
  Pig p1 = new Pig();
  Animal an = p1;

合成一个：Animal an = new Pig();
=左侧：编译器的类型
=右侧：运行期的类型




  public void play(Animal an){
        an.shout();
    }

多态常用的场景：父类当方法的形参，然后传入的具体的子类的对象，然后调同一个方法，
根据传入的子类的不同展现的效果也不同，构成了多态



11.8.3向上转型_向下转型

package com.object.test01;

public class Demo {
    public static void main(String[] args) {
        Pig p = new Pig();
        Animal an = p;
        an.shout();
        //an.eat();//1.报错原因an在编译期是Animal类型，在Animal中没有eat()，方法，也没有weight属性，
        //an.weight = 60.8;//2.内存 an只能看到0x99空间中的Animal部分的内容
        an.age = 10;

    }
}


问题：
//1.报错原因an在编译期是Animal类型，在Animal中没有eat()，方法，也没有weight属性，
//2.内存 an只能看到0x99空间中的Animal部分的内容

解决：
        //加入转型
        //将Animal转为Pig类型
        Pig pig = (Pig)an;
        pig.eat();
        pig.age = 10;
        pig.weight = 60.8; 




11.8.4简单工厂设计模式
不仅可以使用父类做方法的形参，还可以使用父类做方法的返回值类型，真实返回的对象可以是该类的任意一个子类对象。
简单工厂模式的实现，它是解决大量对象创建问题的一个解决方案。将创建和使用分开，工厂负责创建，使用者直接调用即可。简单工厂

模式的基本要求是
   ✧定义一个static方法， 通过类名直接调用
   ✧返回值类型是父类类型，返回的可以是其任意子类类型
   ✧传入一个字符串类型的参数，工厂根据参数创建对应的子类产品


package com.object.test01;

public class Test {
    public static void main(String[] args) {
        //具体的女孩：-->女孩的对象
        Girl g = new Girl();


        Animal an = PetStore.getAnimal("狗");

        g.play(an);
    }
}



package com.object.test01;

public class PetStore {

    public static Animal getAnimal(String petName){
        Animal an = null;

        if("猫".equals(petName) ){ //防止空指针异常  petName.equals("猫")//有空指针异常
            an = new Cat();
        }
        if("狗".equals(petName) ){ //防止空指针异常  petName.equals("猫")//有空指针异常
            an = new Dog();
        }
        if("猪".equals(petName) ){ //防止空指针异常  petName.equals("猫")//有空指针异常
            an = new Pig();
        }

        return an;
    }
}


12final修饰符

1.修饰变量
package com.object.test02;

public class Test {

    public static void main(String[] args) {
       final int A = 103;//final修饰变量，变成常量，变量不能再改变，名字必须大写,final 修饰基本数据类型
       // A = 20;//报错

        final Dog d = new Dog();//final 修饰引用数据类型，那么地址值不能改变
        //d = new Dog();
        d.age = 10;
        d.weight = 13.7;

        //第三种情况
        final Dog d2 = new Dog();
        a(d2);

        //第四种情况
        b(d2);//
    }
    public static void a(Dog d){
        d = new Dog();
    }
    public static void b(final Dog d){//d被final修饰，指向不可以改变
        d = new Dog();//报错
    }
}




2.修饰方法
final修饰方法，那么这个方法不可以被该类的子类重写
package com.object.test02;

public  class Person {
    final public void eat(){
        System.out.println("我可以.........");
    }

}

class Student extends Person{//报错
    @Override
    public void eat(){//报错
        super.eat();
    }
}


3.修饰类
final 修饰类，代表没有子类，该类不可以被继承
一旦一个类被final修饰，那么里面的方法也没有必要写final
package com.object.test02;

public final class Person {
    final public void eat(){
        System.out.println("我可以.........");
    }

}

class Student extends Person{
    @Override
    public void eat(){
        super.eat();
    }
}


[4]案例: JDK提供的Math类:看源码发现: 
(1)使用Math类的时候无需导包，直接使用即可:
package java. lang;|
(2) Math类没有子类，不能被其他类继承了
public final c1ass Mathl {
(3)里面的属性全部被final修饰，方法也是被final修饰的，只是省略不写了
原因:子类没有必要进行重写。
(4)外界不可以创建对象:
Math m = new Math0;
/**
* Don't Let anyone instantiate this class.
*/
private Math() {}

(5)发现Math类中的所有的属性，方法都被static修饰
那么不用创建对象去调用，只能通过类名.属性名类名.方法名去调用



12.1抽象类_抽象方法
1.抽象类中可以定义0-n抽象对象
2.抽象类作用：
在抽象中定义抽象方法，目的：为子类提供一个通用的模板，子类可以在模板的基础上进行开发，
先重写父类的抽象方法，然后可以扩展子类自己的内容，抽象类的设计避免了子类设计的随意性
通过抽象类，子类的设计变得更加严格，进行某些程度上的限制
是子类更加的通用。

3.代码
package com.object.test03;

//4.一个类中如果有方法是抽象方法，，那么这个类也是抽象类
//5.一个抽象可以有0-n个抽象方法

public abstract class Person {
    //1.在一个类中，会有一个方法，子类对这个方法非常满意，无需重写，直接·使用
    public void eat(){
        System.out.println("一顿不吃，饿得慌");
    }
    //2. 在一个类中，会有一个方法，子类对这个方法永远不满意，会对这个方法进行重写
    //3.抽象方法，没有方法体，被abstract 修饰。
    public  abstract void say();
    public  abstract void sleep();

}

//6.抽象类可以被其它类继承
//7.一个类继承一个抽象类，那么这个类可以变成抽象类
//8.一般子类不会加abstract 修饰，一般会让子类重写父类中的方法
//9.子类继承抽象类，就必须重写全部的抽象方法
//10.子类如果没有重写父类全部，抽象方法，那么子类也可以变成一个抽象类
class Student extends Person{
    @Override
    public void say() {
        System.out.println("我xxxxxx");
    }

    @Override
    public void sleep() {
        System.out.println("你xxxxx");
    }
}

class Demo{
    public static void main(String[] args) {
        //11.创建抽象类的对象：-->抽象类不可以创建对象
        //Person p = new Person();

        //12.创建子类的对象：
        Student s = new Student();
        s.sleep();
        s.say();

    //13.多态的写法：父类引用只想子类对象
     Person p = new Student();
     p.sleep();
     p.say();

    }
}



4.
(1).抽象类不能创建对象，那么抽象类中是否有构造器？
抽象类中一定有构造器。构造器的作用：子类初始化对象的时候要先Super调用父类的构造器。

(2).抽象类是否被final修饰？
不能被final 修饰，因为抽象类设计的初衷就是给子类继承用的。要被final修饰了这个抽象类了，
就不存在继承了，就没有子类







13接口
JDk1.8之前
1.接口声明格式：
[访问修饰符] interface 接口名 [extends 父接口1，父接口2]{
	常量定义：
	方法定义：
}

2.代码：
       
package com.object.test04;
/*
1.类是类，接口是接口，他们是同一层次的概念
2.接口没有构造器
3.接口的声明：interface
4.在jdk1.8之前，接口中
（1）常量：固定修饰符public static final
（2）抽象方法:固定修饰符：public abstract
 注意：修饰符可以不写。
* */
public interface TestInterface01 {
    //常量
    public static final int NUM = 10;


    //抽象
    public abstract void a();
    public abstract void b(int num);
    public abstract int c(String name);


}
interface TestInterface02{
    void e();
    void f();
}
/*
5.类和接口的关系是什么？--》实现关系
6.一旦实现一个接口，那么实现类型重写
7.如果没有全部重写抽象方法，那么这个类可以变成一个抽象类
8.Java只有单继承，Java还有多实现
一个类继承其它类，只能直接继承一个父亲
但是实现类实现接口的话，可以实现多个接口
9.写法：先继承，再实现，：extends Person implements TestInterface01,TestInterface02
*/
class Student extends Person implements TestInterface01,TestInterface02{
    @Override
    public void a() {
        System.out.println("---1");
    }

    @Override
    public void b(int num) {
        System.out.println("---2");
    }

    @Override
    public int c(String name) {
        return 100;
    }

    @Override
    public void e() {
        System.out.println("---3");
    }

    @Override
    public void f() {
        System.out.println("---4");
    }
}

class Test{
    public static void main(String[] args) {
        //10.接口不能创建对象
        //TestInterface02 t =new TestInterface01();
        TestInterface02 t = new Student();//接口指向实现类


        //11.接口中常量如何访问：
        System.out.println(TestInterface01.NUM);
        System.out.println(Student.NUM);

        Student s = new Student();
        System.out.println(s.NUM);

        TestInterface01 t2 = new Student();
        System.out.println(t2.NUM);

    }
}


3.接口的作用是什么？
定义规则，只是跟抽象不同地方
接口定义好规则之后，实现类负责实际即可

[4]
继承：子类对父类的继承
实现：实现类对接口的实现

手机 是不是 照相机

继承：手机  extends   照相机   "is-a" 的关系，手机是一个照相机

上面的写法不好：
实现： 手机   implements 拍照手机   "has -a" 的关系  ，手机具备照相的能力


[5]多态的应用场合：
(1)父类当作方法的形参，传入具体的子类的对象
(2)父类当作方法的返回值，返回的是具体的子类的对象
(3)接口当作方法的形参，传入具体的实现类的对象
(4)接口当作方法的返回值，返回值是具体的实现类的对象

[6接口和抽象类的区别：






13.1在JDK1.8之后

[1]被pubic default 修饰的非抽象方法
注意1：default 修饰符必须加上，否则出错
注意2：实现类中要是想重写接口中非抽象方法，那么default修饰符必须不能加，否则出错。

[2]静态方法：
注意1：static 不可以省略不写
注意2：静态方法不能重写

package com.object.test05;

public interface TestInterface2 {
    //常量
    public static final int NUM = 10;

    //抽象方法
    public abstract void a();

    //public default非抽象方法：
    public default void b(){
        System.out.println("xxxxx");
    }

    //静态方法
    public static void c(){
        System.out.println("TestInterface2中的静态方法");
    }


}
class Demo implements TestInterface2{
    @Override
    public void a() {
        System.out.println("重写a方法");
    }

    public static void c(){
        System.out.println("Demo中的静态方法");
    }

}

class A{
    public static void main(String[] args) {
        Demo d = new Demo();
        d.c();
    }
}


疑问:为什么要在接口中加入非抽象方法? ? ?
如果接口中只能定义抽象方法的话，那么我要是修改接口中的内容，
那么对实现类的影响太大了，所有实现类都会受到影响。
现在在接口中加入非抽象方法，对实现类没有影响，想调用就去调用即可。



14.内部类

package com.object.test07;

/*
* 1.类的组成：属性，方法，构造器，代码块，内部类
* 2.内部类：TestOuter的内部的类叫做内部类
* 3.内部类：成员内部类   和  局部内部类（位置：方法内，块内，构造器内）
* 4.成员内部类：
*    里面属性，方法，构造器
*    修饰符：private,default,protect,public,final,abstract
* */
public class TestOuter {

    //成员内部类：
    public  class D{
        String name;
        int age = 20;
        public void method(){
            //5.内部类可以访问外部类的内容
            /*System.out.println(age);
            a();*/
            int age = 30;
            //8.外部类和内部类属性重名的时候，如何进行调用：
            System.out.println(age);//30
            System.out.println(this.age);//20
            System.out.println(TestOuter.this.age);//10
        }
    }

    //静态成员内部类
     static class E{
        public void method(){
            //6.静态内部类只能访问外部类中被static修饰的
           /* System.out.println(age);
            a();*/
        }
     }

    //属性：
    int age = 10;

    //方法：
    public void a(){
        System.out.println("这是a方法");
        {
            System.out.println("这是一个普通块");
            //内部类
            class B{

            }
        }
        //内部类
        class A {

        }
        //7.外部类想要访问内部类：需要创建内部类的对象，然后进行
        D d = new D();
        System.out.println(d.name);
        d.method();
    }

    //构造块
    {
        System.out.println("这是构造块");
    }

    //静态块
    static {
        System.out.println("这是静态块");
    }

    //构造器
    public TestOuter() {
        //内部类
        class C{

        }
    }

    public TestOuter(int age) {
        this.age = age;
    }
}
class Demo{
    public static void main(String[] args) {
        TestOuter to = new TestOuter();
        to.a();

        //创建内部类的对象
        //非静态的成员内部类创建对象
        TestOuter.E e = new TestOuter.E();

        //非静态的成员内部类
       //错误TestOuter.D d = new TestOuter.D();
        TestOuter t = new TestOuter();
        TestOuter.D d =  t.new D();

        


    }
}



14.2局部内部类


package com.object.test08;

public class TestOuter {
    //1.在局部内部类中访问到的变量必须是被final 修饰的
    public void method(){
        int num = 10;
        class A{
            public void a(){
                //num = 20;
                System.out.println(num);
            }
        }
    }
    //2.如果类B在整个项目中只使用一次，那么就没有必要单独使用创建一个B类，使用内部类就可以
    public Comparable method2(){
        class B implements Comparable{
            @Override
            public int compareTo(Object o) {
                return 100;
            }
        }
        return new B();
    }

    public Comparable method3(){
        return  new Comparable(){
            @Override
            public int compareTo(Object o) {
                return 200;
            }
        };
    }
    public void teat(){
        Comparable com = new Comparable() {
            @Override
            public int compareTo(Object o) {
                return 200;
            }
        };
        System.out.println(com.compareTo("abc"));
    }
}



                                       